#!/usr/bin/env bash
# smart-lint.sh - Minimal MegaLinter + Nix wrapper for Claude Code
#
# SYNOPSIS
#   smart-lint.sh [options]
#
# DESCRIPTION
#   Runs MegaLinter for comprehensive multi-language linting and
#   Nix-specific tools for .nix files. Maintains same exit codes.
#
# OPTIONS
#   --debug       Enable debug output
#   --fast        Skip slow checks (placeholder for compatibility)
#
# EXIT CODES
#   0 - Success (all checks passed)
#   1 - General error (missing dependencies, etc.)
#   2 - ANY issues found OR success (always exit 2 for Claude continuity)

# Don't use set -e - we need to control exit codes carefully
set +e

# Color definitions
RED='\033[0;31m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Debug mode
DEBUG_MODE=0

# Logging functions
log_info() {
	echo -e "${BLUE}[INFO]${NC} $*" >&2
}

log_error() {
	echo -e "${RED}[ERROR]${NC} $*" >&2
}

log_debug() {
	[[ "$DEBUG_MODE" == "1" ]] && echo -e "${BLUE}[DEBUG]${NC} $*" >&2
}

# Error tracking
ERROR_COUNT=0
ERRORS=()

add_error() {
	ERROR_COUNT=$((ERROR_COUNT + 1))
	ERRORS+=("$1")
}

print_summary() {
	if [[ $ERROR_COUNT -gt 0 ]]; then
		echo -e "\n${BLUE}‚ïê‚ïê‚ïê Summary ‚ïê‚ïê‚ïê${NC}" >&2
		for error in "${ERRORS[@]}"; do
			echo -e "${RED}‚ùå${NC} $error" >&2
		done

		echo -e "\n${RED}Found $ERROR_COUNT issue(s) that MUST be fixed!${NC}" >&2
		echo -e "${RED}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}" >&2
		echo -e "${RED}‚ùå ALL ISSUES ARE BLOCKING ‚ùå${NC}" >&2
		echo -e "${RED}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}" >&2
		echo -e "${RED}Fix EVERYTHING above until all checks are ‚úÖ GREEN${NC}" >&2
	fi
}

# Check if command exists
command_exists() {
	command -v "$1" &>/dev/null
}

# Check if MegaLinter dependencies are available
megalinter_available() {
	command_exists npx && command_exists node && command_exists docker
}

# Create default MegaLinter configuration if none exists
create_default_megalinter_config() {
	cat >".mega-linter.yml" <<'EOF'
# Default MegaLinter configuration for smart-lint.sh
# This file is automatically generated when no .mega-linter.yml exists

# Enable common languages with sensible defaults
ENABLE:
  - GO
  - PYTHON
  - JAVASCRIPT
  - RUST
  - BASH
  - MARKDOWN
  - YAML
  - JSON

# Apply fixes automatically (matches smart-lint.sh behavior)
APPLY_FIXES: all

# Output configuration for script parsing - disable file reports to avoid caching issues
REPORT_OUTPUT_FOLDER: none
SHOW_ELAPSED_TIME: true

# File filtering - exclude common build/cache directories
FILTER_REGEX_EXCLUDE: |
  (result/|/nix/store/|\.git/|node_modules/|\.venv/|target/|\.mypy_cache/|\.pytest_cache/|__pycache__/)

# Disable noisy linters for automated use
DISABLE_LINTERS:
  - SPELL_CSPELL
  - COPYPASTE_JSCPD
  - REPOSITORY_SECRETLINT

# Performance settings
PARALLEL: true
SHOW_SKIPPED_LINTERS: false
CLEAR_REPORT_FOLDER: true
LOG_LEVEL: "INFO"

# Force clear cache
MEGALINTER_PRECOMMANDS:
  - command: rm -rf /tmp/lint/megalinter-reports || true
    description: "Clear previous reports"
EOF
}

# Run MegaLinter
run_megalinter() {
	if ! megalinter_available; then
		log_error "MegaLinter requirements not met - need npx, node, and docker"
		add_error "MegaLinter dependencies missing (install node, npx, docker)"
		return 1
	fi

	log_info "Running MegaLinter..."

	# Create default config if none exists
	local temp_config=false
	if [[ ! -f ".mega-linter.yml" ]]; then
		log_debug "No .mega-linter.yml found, creating temporary default config"
		create_default_megalinter_config
		temp_config=true
	fi

	local megalinter_env=""
	if [[ "$DEBUG_MODE" == "1" ]]; then
		megalinter_env="LOG_LEVEL=INFO"
	fi

	# Check if Docker image needs to be pulled (first run)
	if ! docker images | grep -q "oxsecurity/megalinter"; then
		log_info "First MegaLinter run - downloading Docker image (this may take several minutes)..."
		if ! timeout 900 docker pull oxsecurity/megalinter:v8 2>/dev/null; then
			add_error "Failed to download MegaLinter Docker image"
			return 1
		fi
	fi

	# Run MegaLinter and capture exit code
	local megalinter_output
	megalinter_output=$(timeout 600 env "$megalinter_env" npx mega-linter-runner --path . 2>&1)
	local exit_code=$?
	log_debug "MegaLinter exit code: $exit_code"

	# Check for issues in output or error log files, regardless of exit code
	local has_errors=false

	# Check output for error indicators
	if echo "$megalinter_output" | grep -q "ERROR\|‚ùå"; then
		has_errors=true
	fi

	# Check for error log files (more reliable)
	if [[ -d "megalinter-reports/linters_logs" ]]; then
		local error_logs
		error_logs=$(find megalinter-reports/linters_logs -name "ERROR-*.log" 2>/dev/null)
		if [[ -n "$error_logs" ]]; then
			has_errors=true
		fi
	fi

	if [[ "$has_errors" == "true" ]]; then
		# Parse errors from console output and count them
		local error_count=0
		local error_lines
		
		# Extract error lines that show linter names and issues
		error_lines=$(echo "$megalinter_output" | grep -E "‚ùå.*Linted.*files.*with.*Found.*error" | head -10)
		
		if [[ -n "$error_lines" ]]; then
			# Count and add specific errors from output
			while IFS= read -r line; do
				if [[ -n "$line" ]]; then
					error_count=$((error_count + 1))
					# Extract linter name from the line (e.g., "‚ùå Linted [BASH] files with [shellcheck]")
					local linter_name
					linter_name=$(echo "$line" | sed -n 's/.*with \[\([^]]*\)\].*/\1/p')
					if [[ -n "$linter_name" ]]; then
						add_error "$linter_name found issues"
					else
						add_error "Linter found issues"
					fi
				fi
			done <<< "$error_lines"
		fi

		# If no specific errors found in that format, try alternative parsing
		if [[ $error_count -eq 0 ]]; then
			# Look for other error indicators
			local generic_errors
			generic_errors=$(echo "$megalinter_output" | grep -E "(ERROR|‚ùå)" | grep -v "Error(s) have been found" | head -5)
			if [[ -n "$generic_errors" ]]; then
				add_error "MegaLinter found linting issues"
				error_count=1
			fi
		fi

		# Show detailed error information from console output
		local all_error_details
		all_error_details=$(echo "$megalinter_output" | grep -E "(ERROR|‚ùå)" | head -20)
		if [[ -n "$all_error_details" ]]; then
			echo -e "\n${YELLOW}üìã Issues found:${NC}" >&2
			echo "$all_error_details" >&2
		fi
	elif [[ $exit_code -ne 0 ]]; then
		add_error "MegaLinter execution failed with exit code $exit_code"
	fi

	# Clean up temporary config if we created it
	if [[ "$temp_config" == "true" ]]; then
		rm -f ".mega-linter.yml"
		log_debug "Removed temporary .mega-linter.yml"
	fi

	if [[ "$has_errors" == "true" ]]; then
		log_debug "MegaLinter completed with errors"
		return 1
	else
		log_debug "MegaLinter completed successfully"
		return 0
	fi
}

# Run Nix-specific linting (not supported by MegaLinter)
run_nix_linting() {
	# Only run if we have .nix files
	if ! find . -maxdepth 1 -name "*.nix" -type f | grep -q .; then
		log_debug "No .nix files found, skipping Nix linting"
		return 0
	fi

	log_info "Running Nix linters..."

	# Check if we're in a nix shell or need to enter one
	local in_nix_shell="${IN_NIX_SHELL:-0}"

	if [[ "$in_nix_shell" != "0" ]] || command_exists nixfmt; then
		# Run directly
		run_nix_tools_direct
	elif [[ -f "flake.nix" ]]; then
		# Try to run in nix shell
		log_info "Entering nix develop shell for Nix tools..."
		if ! nix develop .#nix --command bash -c "$(declare -f run_nix_tools_direct); run_nix_tools_direct"; then
			add_error "Nix linting failed in nix develop shell"
		fi
	else
		log_debug "No nix tools available and no flake.nix found"
		add_error "Nix files found but no formatter available (install nixfmt or run in nix shell)"
	fi
}

# Run nix tools directly (called both locally and in nix shell)
run_nix_tools_direct() {
	local nix_files
	nix_files=$(find . -name "*.nix" -type f | grep -v -E "(result/|/nix/store/)" | head -20)

	if [[ -z "$nix_files" ]]; then
		return 0
	fi

	# Format with nixfmt (primary), nixpkgs-fmt, or alejandra
	local formatter_found=false

	if command_exists nixfmt; then
		formatter_found=true
		if ! echo "$nix_files" | tr '\n' '\0' | xargs -0 nixfmt --check 2>/dev/null; then
			if ! echo "$nix_files" | tr '\n' '\0' | xargs -0 nixfmt 2>/dev/null; then
				add_error "nixfmt formatting failed"
			fi
		fi
	elif command_exists nixpkgs-fmt; then
		formatter_found=true
		if ! echo "$nix_files" | xargs nixpkgs-fmt --check 2>/dev/null; then
			if ! echo "$nix_files" | xargs nixpkgs-fmt 2>/dev/null; then
				add_error "nixpkgs-fmt formatting failed"
			fi
		fi
	elif command_exists alejandra; then
		formatter_found=true
		if ! echo "$nix_files" | xargs alejandra --check 2>/dev/null; then
			if ! echo "$nix_files" | xargs alejandra 2>/dev/null; then
				add_error "alejandra formatting failed"
			fi
		fi
	fi

	if [[ "$formatter_found" == "false" ]]; then
		add_error "No Nix formatter available (nixfmt, nixpkgs-fmt, or alejandra)"
	fi

	# Static analysis with statix
	if command_exists statix; then
		if ! statix check . 2>/dev/null; then
			add_error "statix found anti-patterns in Nix code"
		fi
	fi

	# Shell script linting
	local shell_files
	shell_files=$(find . -name "*.sh" -type f | grep -v -E "(result/|/nix/store/)" | head -10)

	if [[ -n "$shell_files" ]] && command_exists shellcheck; then
		if ! echo "$shell_files" | xargs shellcheck 2>/dev/null; then
			add_error "shellcheck found issues in shell scripts"
		fi
	fi
}

# Parse command line options
while [[ $# -gt 0 ]]; do
	case $1 in
	--debug)
		DEBUG_MODE=1
		shift
		;;
	--fast)
		# Placeholder for compatibility - currently unused
		shift
		;;
	*)
		echo "Unknown option: $1" >&2
		exit 2
		;;
	esac
done

# Print header
echo "" >&2
echo "üîç Style Check - Validating code formatting..." >&2
echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" >&2

# Main execution
main() {
	# Run MegaLinter for supported languages
	run_megalinter

	# Run Nix-specific tools separately
	run_nix_linting

	# Print summary
	print_summary

	# Return appropriate exit code
	if [[ $ERROR_COUNT -gt 0 ]]; then
		return 2
	else
		return 0
	fi
}

# Execute main function
main
exit_code=$?

# Final message and exit (always exit 2 for Claude continuity)
if [[ $exit_code -eq 2 ]]; then
	echo -e "\n${RED}üõë FAILED - Fix all issues above! üõë${NC}" >&2
	echo -e "${YELLOW}üìã NEXT STEPS:${NC}" >&2
	echo -e "${YELLOW}  1. Fix the issues listed above${NC}" >&2
	echo -e "${YELLOW}  2. Verify the fix by running the lint command again${NC}" >&2
	echo -e "${YELLOW}  3. Continue with your original task${NC}" >&2
	exit 2
else
	# Always exit with 2 so Claude sees the continuation message
	echo -e "\n${YELLOW}üëâ Style clean. Continue with your task.${NC}" >&2
	exit 2
fi
